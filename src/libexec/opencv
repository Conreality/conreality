#!/usr/bin/env python2.7
import argparse
import numpy
import cv2
from signal import *
from sys import argv, exit
from syslog import *

WIDTH  = 640
HEIGHT = 480

def parse_arguments(argv):
  parser = argparse.ArgumentParser(description='Conreality driver for OpenCV.')
  group = parser.add_mutually_exclusive_group()
  group.add_argument('-q', '--quiet', action='store_true', help='suppress superfluous output')
  group.add_argument('-v', '--verbose', action='count', help='increase the verbosity level')
  group.add_argument('-d', '--debug', action='store_true', help='enable debugging output')
  parser.add_argument('-w', '--window', action='store_true', help='enable GUI window')
  parser.add_argument('input', nargs='?', default=0, help='input video stream (default: /dev/video0)')
  return parser.parse_args(argv)

def loop(camera, options):
  class State(object):
    def __init__(self):
      self.frame_count = 0 # the number of video frames processed
      self.object = None   # the current object being designated (if any)
      self.objects = []    # the current set of tracked objects

  class Object(object):
    def __init__(self, left=(-1, -1), right=(-1, -1)):
      self.left  = left
      self.right = right
      self.color = (255, 0, 0) # BGR
      self.is_valid = False
    def __str__(self):
      return "Object({}, {})".format(self.left, self.right)

  state = State()

  def process_frame(frame):
    #frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    if state.object and state.object.is_valid:
      cv2.rectangle(frame, state.object.left, state.object.right, state.object.color, 1)
    return frame

  def track_object(object):
    syslog(LOG_INFO, "Tracking new designated object: {}".format(object))
    state.objects.append(object)

  def handle_mouse(event, x, y, flags, param):
    #print (event, x, y, flags, param) # DEBUG
    if event == cv2.EVENT_LBUTTONDOWN:
      state.object = Object((x, y))
    elif event == cv2.EVENT_MOUSEMOVE:
      if state.object:
        state.object.right = (x, y)
        state.object.is_valid = True
    elif event == cv2.EVENT_LBUTTONUP:
      if state.object:
        track_object(state.object)
        state.object = None

  if options.window:
    cv2.setMouseCallback('Conreality', handle_mouse)

  while camera.isOpened():
    success, frame = camera.read()
    if not success:
      if not state.frame_count:
        syslog(LOG_ERR, "Failed to read frame from video capture device; terminating...")
      break # end of video stream
    state.frame_count += 1
    frame = process_frame(frame)
    if options.window:
      cv2.imshow('Conreality', frame)
      cv2.waitKey(1)
    else:
      pause() # TODO

  return state.frame_count

def main(argv):
  class SignalException(Exception):
    def __init__(self, signum):
      self.signum = signum
    def exit_code(self):
      return 0x80 + self.signum

  options = parse_arguments(argv[1:])

  def log_verbosity():
    if options.debug:
      return LOG_DEBUG
    if options.verbose:
      return LOG_INFO
    if options.quiet:
      return LOG_WARNING
    else:
      return LOG_NOTICE

  def video_source():
    if options.input:
      return options.input
    return 0

  def handle_signal(signum, stack_frame):
    syslog(LOG_INFO, "Received a signal ({}), terminating...".format(signum))
    raise SignalException(signum)

  def open_camera():
    camera = cv2.VideoCapture(video_source())
    #camera.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH, WIDTH)
    #camera.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT, HEIGHT)
    #camera.set(cv2.cv.CV_CAP_PROP_FPS, 30)
    return camera

  try:
    log_options = LOG_PID | LOG_CONS | LOG_NDELAY
    if options.debug:
      log_options |= LOG_PERROR
    openlog("conreality", logoption=log_options, facility=LOG_DAEMON)
    setlogmask(LOG_UPTO(log_verbosity()))

    signal(SIGHUP, handle_signal)
    signal(SIGINT, handle_signal)
    signal(SIGPIPE, handle_signal)
    signal(SIGTERM, handle_signal)

    if options.window:
      cv2.namedWindow('Conreality')
      cv2.imshow('Conreality', numpy.zeros((HEIGHT, WIDTH, 3), numpy.uint8))

    camera = open_camera()
    try:
      loop(camera, options)
    finally:
      camera.release()

      if options.window:
        cv2.destroyAllWindows()

  except SignalException as e:
    exit(e.exit_code())
  finally:
    closelog()

if __name__ == '__main__':
  main(argv)
